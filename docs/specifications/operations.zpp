/*
 * P-Lingua Operations Formal Specification (Z++)
 * 
 * This specification formally defines the operations that transform
 * the system state in P-Lingua, covering both compilation and simulation.
 * 
 * Operations are specified with preconditions (what must be true before)
 * and postconditions (what is guaranteed after).
 */

/* ============================================================================
 * IMPORTS
 * ============================================================================ */

-- Import data model and system state specifications
-- (References data_model.zpp and system_state.zpp)

/* ============================================================================
 * SECTION 1: PARSER OPERATIONS
 * ============================================================================ */

/*
 * InitializeParser: Start parsing session
 * 
 * Preconditions:
 * - System is in IDLE mode
 * - Input files are provided
 * - Include paths are valid
 * 
 * Postconditions:
 * - System enters PARSING mode
 * - Parser state is initialized
 * - No errors have occurred
 */
schema InitializeParser
  Î”SystemState
  inputFiles?: seq String
  includePaths?: seq String
  verbosity?: â„•
where
  -- Preconditions
  mode = IDLE
  #inputFiles? > 0
  verbosity? â‰¤ 7
  
  -- Postconditions
  mode' = PARSING
  parserState' â‰  none
  
  let ps = the parserState' in
  ps.files = inputFiles? âˆ§
  ps.includePaths = includePaths? âˆ§
  ps.verbosityLevel = verbosity? âˆ§
  ps.errorCounter = 0 âˆ§
  ps.warningCounter = 0 âˆ§
  ps.currentFile = 0 âˆ§
  ps.currentLine = 0 âˆ§
  ps.currentColumn = 0 âˆ§
  ps.hasStructure = FALSE
  
  simulatorState' = none
end

/*
 * TokenizeInput: Lexical analysis
 * 
 * Performs tokenization of input source code using Flex lexer.
 * 
 * Preconditions:
 * - System is in PARSING mode
 * - Current file is valid
 * 
 * Postconditions:
 * - Tokens are generated and added to parse stream
 * - Current position is updated
 * - Errors are reported if invalid tokens found
 */
schema TokenizeInput
  Î”SystemState
  tokens!: seq Token
where
  -- Preconditions
  mode = PARSING
  let ps = the parserState in
  ps.currentFile âˆˆ dom ps.files
  
  -- Postconditions
  mode' = PARSING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- Position advances
  ps'.currentColumn â‰¥ ps.currentColumn âˆ¨
  ps'.currentLine > ps.currentLine
  
  -- Errors may increase
  ps'.errorCounter â‰¥ ps.errorCounter
  ps'.warningCounter â‰¥ ps.warningCounter
end

/*
 * ParseTokens: Syntax analysis
 * 
 * Builds abstract syntax tree from tokens using Bison parser.
 * 
 * Preconditions:
 * - System is in PARSING mode
 * - Tokens are available
 * 
 * Postconditions:
 * - Syntax tree is constructed
 * - Syntax errors are detected and reported
 * - System may transition to COMPILING mode if successful
 */
schema ParseTokens
  Î”SystemState
  tokens?: seq Token
where
  -- Preconditions
  mode = PARSING
  #tokens? > 0
  
  -- Postconditions
  mode' âˆˆ {PARSING, COMPILING}
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- Tree is constructed
  ps'.root.type = PLINGUA âˆ§
  #ps'.root.children â‰¥ #ps.root.children
  
  -- Successful parse enters compilation
  ps'.errorCounter = ps.errorCounter â‡’ mode' = COMPILING
  
  -- Errors prevent compilation
  ps'.errorCounter > ps.errorCounter â‡’ mode' = PARSING
end

/*
 * ProcessIncludes: Handle @include directives
 * 
 * Processes @include directives by loading referenced files.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - Include nodes exist in syntax tree
 * 
 * Postconditions:
 * - Included files are parsed and integrated
 * - Include paths are searched
 * - Circular includes are detected
 */
schema ProcessIncludes
  Î”SystemState
where
  -- Preconditions
  mode = COMPILING
  let ps = the parserState in
  âˆƒ node: Node â€¢ 
    node.type = INCLUDE âˆ§ descendant(ps.root, node)
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- More files may be added
  #ps'.files â‰¥ #ps.files
  
  -- No circular includes
  Â¬circularInclude(ps'.files)
end

/*
 * RegisterModules: Process module definitions
 * 
 * Registers all def-defined modules (functions) for later use.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - Module definitions exist in syntax tree
 * 
 * Postconditions:
 * - All modules are registered with their names
 * - Module signatures are validated
 * - Duplicate definitions are detected
 */
schema RegisterModules
  Î”SystemState
where
  -- Preconditions
  mode = COMPILING
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- Modules are registered
  âˆ€ node: Node â€¢ 
    node.type = MODULE âˆ§ descendant(ps'.root, node) â‡’ 
      âˆƒ name: String â€¢ 
        name âˆˆ dom ps'.modules âˆ§
        ps'.modules(name) = node
  
  -- No duplicate module names
  âˆ€ m1, m2: dom ps'.modules â€¢ 
    m1 â‰  m2 â‡’ 
      getModuleName(ps'.modules(m1)) â‰  getModuleName(ps'.modules(m2))
end

/*
 * ProcessGlobalVariables: Handle global variable declarations
 * 
 * Processes let statements and command-line variable definitions.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * 
 * Postconditions:
 * - Global variables are registered in memory
 * - Initial values are computed
 * - Type consistency is checked
 */
schema ProcessGlobalVariables
  Î”SystemState
  globalVars?: String â‡¸ Value
where
  -- Preconditions
  mode = COMPILING
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- Global variables are registered
  dom globalVars? âŠ† dom ps'.memory.globalScope.variables
  
  -- Values are set correctly
  âˆ€ name: dom globalVars? â€¢ 
    ps'.memory.globalScope.variables(name).value = globalVars?(name)
end

/*
 * ProcessPatterns: Handle pattern definitions
 * 
 * Processes rule pattern templates for later instantiation.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - Pattern definitions exist
 * 
 * Postconditions:
 * - Patterns are registered
 * - Pattern rules are validated
 * - Patterns can be referenced by name
 */
schema ProcessPatterns
  Î”SystemState
where
  -- Preconditions
  mode = COMPILING
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- All patterns are registered
  âˆ€ node: Node â€¢ 
    node.type = PATTERN âˆ§ descendant(ps'.root, node) â‡’ 
      âˆƒ name: String, rules: â„™ Rule â€¢ 
        name âˆˆ dom ps'.patterns âˆ§
        ps'.patterns(name) = rules âˆ§
        âˆ€ r: rules â€¢ "pattern" âˆˆ dom r.features.attributes
end

/*
 * ProcessModel: Handle @model definition
 * 
 * Processes the semantic model definition for the P-system.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - Model definition exists
 * 
 * Postconditions:
 * - Model semantics are registered
 * - Pattern references are validated
 * - Model is stored for later use
 */
schema ProcessModel
  Î”SystemState
where
  -- Preconditions
  mode = COMPILING
  let ps = the parserState in
  âˆƒ node: Node â€¢ 
    node.type = MODEL âˆ§ descendant(ps.root, node)
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- Model is registered
  âˆƒ name: String, sem: Semantics â€¢ 
    name âˆˆ dom ps'.models âˆ§
    ps'.models(name) = sem
  
  -- All pattern references are valid
  âˆ€ name: String, sem: Semantics â€¢ 
    name âˆˆ dom ps'.models âˆ§ sem = ps'.models(name) â‡’ 
      âˆ€ pattern: sem.patterns â€¢ 
        pattern âˆˆ dom ps'.patterns
end

/*
 * ExecuteMain: Execute main() function
 * 
 * Executes the main function to construct the P-system.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - main() function is defined
 * - All modules are registered
 * 
 * Postconditions:
 * - Main function is executed
 * - Membrane structure is defined
 * - Initial multisets are specified
 * - Rules are generated
 */
schema ExecuteMain
  Î”SystemState
  args?: seq Value
where
  -- Preconditions
  mode = COMPILING
  let ps = the parserState in
  "main" âˆˆ dom ps.modules
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- Structure is now defined
  ps'.hasStructure = TRUE
  
  -- Structure exists in memory
  âˆƒ node: Node â€¢ 
    node.type = MEMBRANE_STRUCTURE âˆ§
    descendant(ps'.root, node)
end

/*
 * UnrollRanges: Expand range-based constructs
 * 
 * Expands ranges in multisets, rules, and labels.
 * Example: a{i} : 1<=i<=10 becomes a{1}, a{2}, ..., a{10}
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - Ranges are present in constructs
 * 
 * Postconditions:
 * - All ranges are expanded
 * - Concrete instances are generated
 * - Range variables are properly substituted
 */
schema UnrollRanges
  Î”SystemState
where
  -- Preconditions
  mode = COMPILING
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- No range nodes remain
  Â¬(âˆƒ node: Node â€¢ 
    node.type = RANGE âˆ§ descendant(ps'.root, node))
  
  -- All instances are generated
  âˆ€ range: RangeSpec â€¢ 
    inOriginalTree(range, ps.root) â‡’ 
      allInstancesGenerated(range, ps'.root)
end

/*
 * UnrollPatterns: Instantiate pattern rules
 * 
 * Instantiates pattern templates with concrete rules.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - Patterns are defined
 * - Rules reference patterns
 * 
 * Postconditions:
 * - Pattern rules are instantiated
 * - Concrete rules are generated
 * - Pattern constraints are satisfied
 */
schema UnrollPatterns
  Î”SystemState
where
  -- Preconditions
  mode = COMPILING
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- All pattern references are resolved
  âˆ€ rule: Rule â€¢ 
    "pattern" âˆˆ dom rule.features.attributes â‡’ 
      rule.features.attributes("pattern").stringValue âˆˆ dom ps'.patterns
end

/*
 * ValidatePsystem: Semantic validation
 * 
 * Validates the constructed P-system for semantic correctness.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - P-system is fully constructed
 * 
 * Postconditions:
 * - All semantic rules are checked
 * - Errors are reported if validation fails
 * - System remains in COMPILING if valid
 */
schema ValidatePsystem
  Î”SystemState
where
  -- Preconditions
  mode = COMPILING
  let ps = the parserState in
  ps.hasStructure = TRUE
  
  -- Postconditions
  mode' = COMPILING
  
  let ps = the parserState in
  let ps' = the parserState' in
  
  -- Validation checks performed
  structureIsValid(ps') âˆ§
  rulesAreValid(ps') âˆ§
  semanticsAreConsistent(ps')
  
  -- Errors reported if invalid
  ps'.errorCounter > ps.errorCounter â‡’ 
    Â¬(structureIsValid(ps') âˆ§ 
      rulesAreValid(ps') âˆ§ 
      semanticsAreConsistent(ps'))
end

/*
 * GenerateOutput: Produce output file
 * 
 * Generates output in the specified format.
 * 
 * Preconditions:
 * - System is in COMPILING mode
 * - P-system is valid
 * - Output format is specified
 * 
 * Postconditions:
 * - Output file is generated
 * - Format is correct
 * - File is written to disk
 */
schema GenerateOutput
  Î”SystemState
  success!: ğ”¹
where
  -- Preconditions
  mode = COMPILING
  let ps = the parserState in
  ps.hasStructure = TRUE âˆ§
  ps.errorCounter = 0 âˆ§
  #ps.outputFile.str_ > 0 âˆ§
  ps.outputFormat âˆˆ {"json", "xml", "bin", "bin2", "c++"}
  
  -- Postconditions
  mode' = IDLE
  success! = TRUE â‡” ps.errorCounter = 0
  
  -- Output generated
  success! = TRUE â‡’ 
    fileWritten(ps.outputFile, ps.outputFormat)
end

/* ============================================================================
 * SECTION 2: SIMULATOR OPERATIONS
 * ============================================================================ */

/*
 * InitializeSimulator: Start simulation
 * 
 * Initializes the simulator with a compiled P-system.
 * 
 * Preconditions:
 * - System is in IDLE mode
 * - Input file contains valid P-system
 * 
 * Postconditions:
 * - System enters SIMULATING mode
 * - Configuration is initialized
 * - Rules are indexed
 */
schema InitializeSimulator
  Î”SystemState
  inputFile?: String
  configFile?: String option
  maxSteps?: â„•
  randomized?: ğ”¹
  verbosity?: â„•
where
  -- Preconditions
  mode = IDLE
  #inputFile?.str_ > 0
  verbosity? â‰¤ 7
  
  -- Postconditions
  mode' = SIMULATING
  simulatorState' â‰  none
  
  let ss = the simulatorState' in
  ss.maxSteps = maxSteps? âˆ§
  ss.randomized = randomized? âˆ§
  ss.verbosityLevel = verbosity? âˆ§
  ss.finished = FALSE âˆ§
  ss.initialTime = ss.configuration.time
  
  -- Configuration is initialized
  configFile? = none â‡’ 
    ss.configuration.time = 0 âˆ§
    configurationFromStructure(ss.file.psystem.structure, ss.configuration)
  
  configFile? â‰  none â‡’ 
    configurationFromFile(the configFile?, ss.configuration)
  
  -- Rules are indexed
  allRulesIndexed(ss.file.psystem.rules, ss.ruleSets)
  
  parserState' = none
end

/*
 * SelectRules: Rule selection phase
 * 
 * Selects rules to apply in the current step using maximal parallelism.
 * 
 * Preconditions:
 * - System is in SIMULATING mode
 * - Simulation is not finished
 * 
 * Postconditions:
 * - Rules are selected for each membrane
 * - Priority levels are respected
 * - Semantics constraints are satisfied
 * - Maximum parallelism is achieved
 */
schema SelectRules
  Î”SystemState
where
  -- Preconditions
  mode = SIMULATING
  let ss = the simulatorState in
  ss.finished = FALSE
  
  -- Postconditions
  mode' = SIMULATING
  
  let ss = the simulatorState in
  let ss' = the simulatorState' in
  
  -- Configuration unchanged
  ss'.configuration = ss.configuration
  
  -- Rules selected
  âˆ€ sr: ss'.selectedRules â€¢ 
    let m = ss'.configuration.membranes(sr.membraneId) in
    let rules = ss'.ruleSets.rules(m.label)(m.charge.charge) in
    sr.ruleIndex âˆˆ dom rules âˆ§
    canApplyRule(m, rules(sr.ruleIndex), sr.applications, ss'.configuration)
  
  -- Priority respected
  âˆ€ sr: ss'.selectedRules â€¢ 
    let m = ss'.configuration.membranes(sr.membraneId) in
    let rule = getRuleByIndex(ss'.ruleSets, m, sr.ruleIndex) in
    priority(rule) â‰¤ m.priorityLevel
  
  -- Maximal parallelism (if not randomized)
  ss.randomized = FALSE â‡’ 
    âˆ€ sr: ss'.selectedRules â€¢ 
      sr.applications = maxApplications(sr, ss'.configuration)
  
  -- Semantics satisfied
  âˆ€ sr: ss'.selectedRules â€¢ 
    let m = ss'.configuration.membranes(sr.membraneId) in
    let rule = getRuleByIndex(ss'.ruleSets, m, sr.ruleIndex) in
    semanticsSatisfied(m.semantics, rule, sr.applications)
end

/*
 * ExecuteRules: Rule execution phase
 * 
 * Executes all selected rules, updating the configuration.
 * 
 * Preconditions:
 * - System is in SIMULATING mode
 * - Rules have been selected
 * 
 * Postconditions:
 * - Objects are consumed and produced
 * - Membranes are modified (charge, division, dissolution)
 * - Time is incremented
 * - Selected rules are cleared
 */
schema ExecuteRules
  Î”SystemState
where
  -- Preconditions
  mode = SIMULATING
  let ss = the simulatorState in
  ss.selectedRules â‰  âˆ…
  
  -- Postconditions
  mode' = SIMULATING
  
  let ss = the simulatorState in
  let ss' = the simulatorState' in
  
  -- Time increments
  ss'.configuration.time = ss.configuration.time + 1
  
  -- Selected rules cleared
  ss'.selectedRules = âˆ…
  
  -- Objects consumed
  âˆ€ sr: ss.selectedRules â€¢ 
    objectsConsumed(sr, ss.configuration, ss'.configuration)
  
  -- Objects produced
  âˆ€ sr: ss.selectedRules â€¢ 
    objectsProduced(sr, ss.configuration, ss'.configuration)
  
  -- Membranes divided if needed
  âˆ€ sr: ss.selectedRules â€¢ 
    let rule = getRuleBySelection(sr, ss.ruleSets, ss.configuration) in
    #rule.rhr.producedMembranes > 1 â‡’ 
      membraneDivided(sr.membraneId, rule, ss.configuration, ss'.configuration)
  
  -- Membranes dissolved if needed
  âˆ€ sr: ss.selectedRules â€¢ 
    let rule = getRuleBySelection(sr, ss.ruleSets, ss.configuration) in
    markedForDissolution(sr.membraneId, rule) â‡’ 
      membraneDissolved(sr.membraneId, ss.configuration, ss'.configuration)
end

/*
 * SimulationStep: Complete simulation step
 * 
 * Performs one complete simulation step (select + execute).
 * 
 * Preconditions:
 * - System is in SIMULATING mode
 * - Simulation is not finished
 * 
 * Postconditions:
 * - Rules are selected and executed
 * - Configuration is updated
 * - Finished flag may be set
 */
schema SimulationStep
  Î”SystemState
where
  -- Preconditions
  mode = SIMULATING
  let ss = the simulatorState in
  ss.finished = FALSE
  
  -- Composition of SelectRules and ExecuteRules
  âˆƒ SystemState'' â€¢ 
    SelectRules âˆ§ 
    [SystemState' / SystemState''] âˆ§ 
    [SystemState'' / SystemState] âˆ§ 
    ExecuteRules
  
  -- Postconditions
  mode' = SIMULATING
  
  let ss = the simulatorState in
  let ss' = the simulatorState' in
  
  -- Time advanced
  ss'.configuration.time = ss.configuration.time + 1
  
  -- Finished check
  ss'.finished = TRUE â‡” 
    (ss.maxSteps > 0 âˆ§ 
     ss'.configuration.time - ss.initialTime â‰¥ ss.maxSteps) âˆ¨
    ss'.selectedRules = âˆ…
end

/*
 * RunSimulation: Run complete simulation
 * 
 * Runs simulation until completion or max steps reached.
 * 
 * Preconditions:
 * - System is in SIMULATING mode
 * - Simulation is initialized
 * 
 * Postconditions:
 * - Simulation runs to completion
 * - Final configuration is available
 * - System returns to IDLE mode
 */
schema RunSimulation
  Î”SystemState
  finalConfig!: Configuration
where
  -- Preconditions
  mode = SIMULATING
  
  -- Multiple simulation steps
  âˆƒ states: seq SystemState â€¢ 
    #states > 0 âˆ§
    states(1) = Î¸SystemState âˆ§
    states(#states) = Î¸SystemState' âˆ§
    âˆ€ i: 1..(#states - 1) â€¢ 
      SimulationStep[states(i) / SystemState, states(i+1) / SystemState']
  
  -- Postconditions
  mode' = IDLE
  let ss = the simulatorState in
  ss.finished = TRUE
  finalConfig! = ss.configuration
  
  simulatorState' = none
end

/* ============================================================================
 * SECTION 3: MEMBRANE OPERATIONS
 * ============================================================================ */

/*
 * CopyMembrane: Duplicate a membrane
 * 
 * Creates a copy of a membrane with all its contents and children.
 * Used in membrane division.
 * 
 * Preconditions:
 * - Source membrane exists
 * - Source membrane is not dissolved
 * 
 * Postconditions:
 * - New membrane is created
 * - Contents are copied
 * - Structure is preserved
 * - New membrane has valid parent
 */
schema CopyMembrane
  Î”Configuration
  sourceMembId?: â„•
  newMembId!: â„•
where
  -- Preconditions
  sourceMembId? âˆˆ dom membranes
  membranes(sourceMembId?).parent â‰  -2
  
  -- Postconditions
  newMembId! âˆˆ dom membranes'
  newMembId! âˆ‰ dom membranes
  
  let source = membranes(sourceMembId?) in
  let copy = membranes'(newMembId!) in
  
  -- Properties copied
  copy.label = source.label âˆ§
  copy.charge = source.charge âˆ§
  copy.multiset = source.multiset âˆ§
  copy.parent = source.parent
  
  -- Children copied recursively
  #copy.children = #source.children âˆ§
  âˆ€ i: dom source.children â€¢ 
    âˆƒ childCopy: â„• â€¢ 
      childCopy âˆˆ ran copy.children âˆ§
      isomorphicMembrane(membranes'(childCopy), membranes(source.children(i)))
end

/*
 * DissolveMembrane: Dissolve a membrane
 * 
 * Removes a membrane and moves its contents to parent.
 * 
 * Preconditions:
 * - Membrane exists
 * - Membrane is marked for dissolution
 * 
 * Postconditions:
 * - Membrane is removed
 * - Contents moved to parent
 * - Children become siblings
 * - Index marked as free
 */
schema DissolveMembrane
  Î”Configuration
  membId?: â„•
where
  -- Preconditions
  membId? âˆˆ dom membranes
  membranes(membId?).multiset.objects("@d").multiplicity > 0 âˆ¨
  markedForDissolution(membId?)
  
  -- Postconditions
  let source = membranes(membId?) in
  
  -- Membrane marked as free
  membranes'(membId?).parent = -2
  membranes'(membId?).multiset.objects = âˆ…
  membranes'(membId?).children = âŸ¨âŸ©
  
  -- Contents moved to parent
  source.parent â‰  -1 â‡’ 
    let parent = membranes(source.parent) in
    let parent' = membranes'(source.parent) in
    âˆ€ obj: dom source.multiset.objects â€¢ 
      parent'.multiset.objects(obj).multiplicity = 
        parent.multiset.objects(obj).multiplicity + 
        source.multiset.objects(obj).multiplicity
  
  -- Contents moved to environment
  source.parent = -1 â‡’ 
    âˆ€ obj: dom source.multiset.objects â€¢ 
      environment'.objects(obj).multiplicity = 
        environment.objects(obj).multiplicity + 
        source.multiset.objects(obj).multiplicity
  
  -- Children reparented
  source.parent â‰  -1 â‡’ 
    âˆ€ child: ran source.children â€¢ 
      membranes'(child).parent = source.parent âˆ§
      child âˆˆ ran membranes'(source.parent).children
end

/*
 * ChangeCharge: Modify membrane charge
 * 
 * Changes the electrical charge of a membrane.
 * 
 * Preconditions:
 * - Membrane exists
 * - New charge is valid
 * 
 * Postconditions:
 * - Charge is updated
 * - Other properties unchanged
 */
schema ChangeCharge
  Î”Configuration
  membId?: â„•
  newCharge?: â„¤
where
  -- Preconditions
  membId? âˆˆ dom membranes
  newCharge? âˆˆ {-1, 0, 1}
  
  -- Postconditions
  membranes'(membId?).charge.charge = newCharge?
  
  -- Everything else unchanged
  membranes'(membId?).label = membranes(membId?).label
  membranes'(membId?).multiset = membranes(membId?).multiset
  membranes'(membId?).parent = membranes(membId?).parent
  membranes'(membId?).children = membranes(membId?).children
end

/* ============================================================================
 * SECTION 4: MULTISET OPERATIONS
 * ============================================================================ */

/*
 * AddObjects: Add objects to multiset
 * 
 * Adds a multiset of objects to an existing multiset.
 * 
 * Preconditions:
 * - Objects to add are well-formed
 * - Multiplicities are positive
 * 
 * Postconditions:
 * - Multiplicities are summed
 * - New objects are added
 */
schema AddObjects
  Î”Multiset
  toAdd?: Multiset
  factor?: â„•â‚
where
  -- Preconditions
  factor? > 0
  âˆ€ obj: dom toAdd?.objects â€¢ 
    toAdd?.objects(obj).multiplicity > 0
  
  -- Postconditions
  âˆ€ obj: dom toAdd?.objects â€¢ 
    objects'(obj).multiplicity = 
      (obj âˆˆ dom objects â‡’ objects(obj).multiplicity | 0) +
      toAdd?.objects(obj).multiplicity * factor?
  
  -- Other objects unchanged
  âˆ€ obj: dom objects â€¢ 
    obj âˆ‰ dom toAdd?.objects â‡’ 
      objects'(obj) = objects(obj)
end

/*
 * RemoveObjects: Remove objects from multiset
 * 
 * Removes a multiset of objects from an existing multiset.
 * 
 * Preconditions:
 * - Objects to remove exist in sufficient quantity
 * - Multiplicities are positive
 * 
 * Postconditions:
 * - Multiplicities are subtracted
 * - Objects with zero multiplicity are removed
 */
schema RemoveObjects
  Î”Multiset
  toRemove?: Multiset
  factor?: â„•â‚
where
  -- Preconditions
  factor? > 0
  âˆ€ obj: dom toRemove?.objects â€¢ 
    obj âˆˆ dom objects âˆ§
    objects(obj).multiplicity â‰¥ 
      toRemove?.objects(obj).multiplicity * factor?
  
  -- Postconditions
  âˆ€ obj: dom toRemove?.objects â€¢ 
    let newMult = objects(obj).multiplicity - 
                  toRemove?.objects(obj).multiplicity * factor? in
    newMult > 0 â‡’ objects'(obj).multiplicity = newMult
    newMult = 0 â‡’ obj âˆ‰ dom objects'
  
  -- Other objects unchanged
  âˆ€ obj: dom objects â€¢ 
    obj âˆ‰ dom toRemove?.objects â‡’ 
      objects'(obj) = objects(obj)
end

/*
 * CountMultiset: Count how many times a multiset fits
 * 
 * Calculates the maximum number of times a multiset can be
 * subtracted from another multiset.
 * 
 * Preconditions:
 * - Both multisets are well-formed
 * 
 * Postconditions:
 * - Count is returned
 * - Count is maximum possible
 */
schema CountMultiset
  ÎMultiset
  pattern?: Multiset
  count!: â„•
where
  -- Empty pattern matches infinitely
  pattern?.objects = âˆ… â‡’ count! = âˆ
  
  -- Non-empty pattern
  pattern?.objects â‰  âˆ… â‡’ 
    count! = min({ objects(obj).multiplicity div 
                   pattern?.objects(obj).multiplicity | 
                   obj: dom pattern?.objects âˆ§ obj âˆˆ dom objects })
  
  -- If any object missing, count is 0
  (âˆƒ obj: dom pattern?.objects â€¢ obj âˆ‰ dom objects) â‡’ 
    count! = 0
end

/* ============================================================================
 * SECTION 5: HELPER PREDICATES AND FUNCTIONS
 * ============================================================================ */

-- Predicates used in operation specifications

descendant: Node Ã— Node â†’ ğ”¹
circularInclude: seq String â†’ ğ”¹
getModuleName: Node â†’ String
inOriginalTree: RangeSpec Ã— Node â†’ ğ”¹
allInstancesGenerated: RangeSpec Ã— Node â†’ ğ”¹
structureIsValid: ParserState â†’ ğ”¹
rulesAreValid: ParserState â†’ ğ”¹
semanticsAreConsistent: ParserState â†’ ğ”¹
fileWritten: String Ã— String â†’ ğ”¹
configurationFromStructure: Membrane Ã— Configuration â†’ ğ”¹
configurationFromFile: String Ã— Configuration â†’ ğ”¹
allRulesIndexed: â„™ Rule Ã— RuleSet â†’ ğ”¹
canApplyRule: CMembrane Ã— Rule Ã— â„• Ã— Configuration â†’ ğ”¹
getRuleByIndex: RuleSet Ã— CMembrane Ã— â„• â†’ Rule
maxApplications: SelectedRule Ã— Configuration â†’ â„•
semanticsSatisfied: Semantics Ã— Rule Ã— â„• â†’ ğ”¹
objectsConsumed: SelectedRule Ã— Configuration Ã— Configuration â†’ ğ”¹
objectsProduced: SelectedRule Ã— Configuration Ã— Configuration â†’ ğ”¹
membraneDivided: â„• Ã— Rule Ã— Configuration Ã— Configuration â†’ ğ”¹
markedForDissolution: â„• Ã— Rule â†’ ğ”¹
membraneDissolved: â„• Ã— Configuration Ã— Configuration â†’ ğ”¹
getRuleBySelection: SelectedRule Ã— RuleSet Ã— Configuration â†’ Rule
isomorphicMembrane: CMembrane Ã— CMembrane â†’ ğ”¹

/* ============================================================================
 * END OF OPERATIONS SPECIFICATION
 * ============================================================================ */
