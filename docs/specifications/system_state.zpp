/*
 * P-Lingua System State Formal Specification (Z++)
 * 
 * This specification formally defines the system state for both the
 * compiler/parser and the simulator components of P-Lingua.
 * 
 * It builds upon the data model specification and defines how state
 * evolves during compilation and simulation.
 */

/* ============================================================================
 * IMPORTS FROM DATA MODEL
 * ============================================================================ */

-- Import all data model schemas
-- (In practice, this would reference data_model.zpp)
-- Here we reference key types that are used

-- Basic types
Value, Multiplicity, String, ObjectString, LabelString, FeatureString

-- Composite types
Label, Multiset, Features

-- Membrane types
Membrane, IMembrane, OMembrane, CMembrane

-- Rule types
Rule, LHR, RHR, Semantics

-- P-System types
Psystem, Configuration, File

-- Auxiliary types
UId, Alphabet

/* ============================================================================
 * SECTION 1: PARSER STATE
 * ============================================================================ */

/*
 * NodeType: Types of syntax tree nodes
 * 
 * The parser builds an Abstract Syntax Tree (AST) where each node
 * has a specific type indicating its syntactic role.
 */
NodeType ::= 
  -- Top-level
  PLINGUA | DEFINITIONS | DEFINITION | MODULE | INCLUDE |
  -- Variables and expressions
  VARIABLE | EXPR | LITERAL | BINARY_OP | UNARY_OP |
  -- Control flow
  IF | ELSE | WHILE | DO | FOR | RETURN |
  -- System structures
  MEMBRANE_STRUCTURE | MULTISET | RULE | PATTERN |
  -- Call expressions
  CALL | SYSTEM_CALL | ARGUMENTS | PARAMETERS |
  -- Model definition
  MODEL | MODEL_DEFINITION | MODEL_BODY |
  -- Features
  FEATURE | PRIORITY | PROBABILITY

/*
 * ErrorLevel: Severity of parser messages
 */
ErrorLevel ::= FATAL | ERROR | WARNING | INFO | 
               DEBUG_1 | DEBUG_2 | DEBUG_3 | DEBUG_4

/*
 * Location: Source code position
 * 
 * Tracks the position of a token or node in the source code
 * for error reporting and debugging.
 * 
 * Invariants:
 * - Line and column numbers are positive
 * - End position is after or equal to start position
 */
schema Location
  file: â„•
  first_line: â„•â‚
  first_column: â„•â‚
  last_line: â„•â‚
  last_column: â„•â‚
  valid: ð”¹
where
  valid = TRUE â‡’ 
    (last_line > first_line âˆ¨ 
     (last_line = first_line âˆ§ last_column â‰¥ first_column))
end

/*
 * NodeValue: Value stored in a syntax tree node
 * 
 * Nodes can store various types of values depending on their role.
 * This is a union type similar to the Value type but used specifically
 * for AST nodes.
 */
schema NodeValue
  value: Value
  -- Additional node-specific data could be added here
where
  -- Value must be well-formed
end

/*
 * Node: Syntax tree node
 * 
 * Represents a node in the Abstract Syntax Tree built by the parser.
 * 
 * Components:
 * - type: The syntactic type of this node
 * - value: Optional value stored at this node
 * - loc: Source location information
 * - children: Child nodes in the tree
 * 
 * Invariants:
 * - Children are well-formed nodes
 * - Location is valid if node is from source
 */
schema Node
  type: NodeType
  value: NodeValue
  loc: Location
  children: seq Node
where
  -- All children are reachable and well-formed
  âˆ€ child: ran children â€¢ child.loc.valid â‡’ 
    child.loc.file = loc.file
end

/*
 * Scope: Variable scope management
 * 
 * Manages variable bindings and their visibility during parsing
 * and semantic analysis.
 * 
 * Invariants:
 * - Variables are uniquely named within a scope
 * - Parent scope is properly linked
 */
schema Scope
  variables: String â‡¸ NodeValue
  parent: Scope option
where
  -- Variables in this scope are well-defined
  âˆ€ name: dom variables â€¢ variables(name).value.type_ âˆˆ ValueType
end

/*
 * Memory: Global memory state
 * 
 * Maintains the runtime state of variables during parsing and
 * unrolling of P-Lingua programs.
 */
schema Memory
  globalScope: Scope
  currentScope: Scope
  scopeStack: seq Scope
where
  -- Current scope is on the stack or is global
  currentScope âˆˆ ran scopeStack âˆ¨ currentScope = globalScope
  
  -- Stack is properly nested
  âˆ€ i: dom scopeStack â€¢ 
    i > 1 â‡’ scopeStack(i).parent = some scopeStack(i-1)
end

/*
 * ParserState: Complete parser state
 * 
 * Maintains all information needed during parsing and compilation
 * of P-Lingua source files.
 * 
 * Components:
 * - files: List of input files being processed
 * - includePaths: Directories to search for includes
 * - lines: Source code lines for each file
 * - currentFile: Index of file currently being parsed
 * - currentLine: Current line number
 * - currentColumn: Current column number
 * - errorCounter: Number of errors encountered
 * - warningCounter: Number of warnings encountered
 * - verbosityLevel: Detail level for output (0-7)
 * - root: Root of the syntax tree
 * - memory: Variable storage and scoping
 * - modules: Defined modules (functions)
 * - patterns: Defined rule patterns
 * - models: Defined semantic models
 * - hasStructure: Whether membrane structure has been defined
 * - outputFormat: Desired output format
 * - outputFile: Output file path
 * 
 * Invariants:
 * - Current file index is valid
 * - Current line/column are within file bounds
 * - Error counts are non-negative
 * - Verbosity level is in valid range
 * - Root node is well-formed
 */
schema ParserState
  files: seq String
  includePaths: seq String
  lines: seq (seq String)
  currentFile: â„•
  currentLine: â„•
  currentColumn: â„•
  errorCounter: â„•
  warningCounter: â„•
  verbosityLevel: â„•
  root: Node
  memory: Memory
  modules: String â‡¸ Node
  patterns: String â‡¸ â„™ Rule
  models: String â‡¸ Semantics
  hasStructure: ð”¹
  outputFormat: String
  outputFile: String
where
  -- Valid file index
  #files > 0 â‡’ currentFile âˆˆ dom files
  
  -- Valid line/column
  currentFile âˆˆ dom files âˆ§ currentFile âˆˆ dom lines â‡’ 
    currentLine âˆˆ dom lines(currentFile)
  
  -- Valid verbosity
  verbosityLevel â‰¤ 7
  
  -- Root is valid
  root.type = PLINGUA
  
  -- All modules are well-formed
  âˆ€ name: dom modules â€¢ 
    modules(name).type = MODULE
  
  -- All patterns are valid rules
  âˆ€ patternName: dom patterns â€¢ 
    âˆ€ rule: patterns(patternName) â€¢ 
      "pattern" âˆˆ dom rule.features.attributes
  
  -- Output format is recognized
  outputFormat âˆˆ {"json", "xml", "bin", "bin2", "c++"}
end

/* ============================================================================
 * SECTION 2: SIMULATOR STATE
 * ============================================================================ */

/*
 * RuleSet: Rules indexed by membrane type
 * 
 * For efficient simulation, rules are pre-indexed by the membrane
 * label and charge they apply to.
 * 
 * Structure: Label â†’ Charge â†’ Sequence of Rules
 * 
 * Invariants:
 * - All rules in a set match the indexing key
 * - Rules are sorted by priority
 */
schema RuleSet
  rules: Label â‡¸ (â„¤ â‡¸ seq Rule)
where
  -- Valid charge values
  âˆ€ label: dom rules â€¢ 
    âˆ€ charge: dom rules(label) â€¢ 
      charge âˆˆ {-1, 0, 1}
  
  -- All rules match their index
  âˆ€ label: dom rules â€¢ 
    âˆ€ charge: dom rules(label) â€¢ 
      âˆ€ rule: ran rules(label)(charge) â€¢ 
        rule.lhr.membrane.label = label âˆ§
        rule.lhr.membrane.charge.charge = charge
  
  -- Rules are sorted by priority
  âˆ€ label: dom rules â€¢ 
    âˆ€ charge: dom rules(label) â€¢ 
      let ruleSeq = rules(label)(charge) in
      âˆ€ i: 1..(#ruleSeq - 1) â€¢ 
        priority(ruleSeq(i)) â‰¤ priority(ruleSeq(i+1))
end

-- Helper function to get rule priority
priority: Rule â†’ â„¤

âˆ€ r: Rule â€¢
  priority(r) = 
    if "priority" âˆˆ dom r.features.attributes
    then r.features.attributes("priority").longValue
    else 0

/*
 * SelectedRule: A rule selected for execution
 * 
 * During simulation, rules are selected with a specific number
 * of applications for a specific membrane instance.
 * 
 * Components:
 * - membraneId: Index of the membrane in the configuration
 * - ruleIndex: Index of the rule in the rule set
 * - applications: Number of times to apply the rule
 * 
 * Invariants:
 * - Applications is positive
 * - Indices are valid
 */
schema SelectedRule
  membraneId: â„•
  ruleIndex: â„•
  applications: â„•â‚
where
  applications > 0
end

/*
 * SimulatorState: Complete simulator state
 * 
 * Maintains all information needed during P-system simulation.
 * 
 * Components:
 * - file: The P-system being simulated
 * - configuration: Current system configuration
 * - ruleSets: Pre-indexed rules for efficiency
 * - selectedRules: Rules selected for current step
 * - freeIndexes: Recycled membrane indices
 * - finished: Whether simulation has completed
 * - initialTime: Starting time step
 * - maxSteps: Maximum steps to simulate (0 = unlimited)
 * - randomized: Whether to use randomized selection
 * - verbosityLevel: Output detail level
 * - configurationFile: Optional initial configuration
 * - outputFile: Optional output file
 * 
 * Invariants:
 * - Configuration is well-formed
 * - Selected rules reference valid membranes
 * - Free indexes are valid and unused
 * - Time progresses monotonically
 */
schema SimulatorState
  file: File
  configuration: Configuration
  ruleSets: RuleSet
  selectedRules: â„™ SelectedRule
  freeIndexes: seq â„•
  finished: ð”¹
  initialTime: â„•
  maxSteps: â„•
  randomized: ð”¹
  verbosityLevel: â„•
  configurationFile: String option
  outputFile: String option
where
  -- Configuration time is valid
  configuration.time â‰¥ initialTime
  
  -- Selected rules reference valid membranes
  âˆ€ sr: selectedRules â€¢ 
    sr.membraneId âˆˆ dom configuration.membranes âˆ§
    sr.membraneId âˆ‰ ran freeIndexes
  
  -- Free indexes are within bounds
  âˆ€ idx: ran freeIndexes â€¢ 
    idx âˆˆ dom configuration.membranes
  
  -- Free indexes are actually free (parent = -2)
  âˆ€ idx: ran freeIndexes â€¢ 
    configuration.membranes(idx).parent = -2
  
  -- Free indexes are unique
  âˆ€ i, j: dom freeIndexes â€¢ 
    i â‰  j â‡’ freeIndexes(i) â‰  freeIndexes(j)
  
  -- Verbosity is valid
  verbosityLevel â‰¤ 7
  
  -- Finished when max steps reached or no rules selected
  finished = TRUE â‡” 
    (maxSteps > 0 âˆ§ configuration.time - initialTime â‰¥ maxSteps) âˆ¨
    selectedRules = âˆ…
end

/* ============================================================================
 * SECTION 3: SYSTEM STATE (COMBINED)
 * ============================================================================ */

/*
 * SystemState: Top-level system state
 * 
 * The complete state of the P-Lingua system, which can be in
 * one of several modes: parsing, compiling, or simulating.
 * 
 * Components:
 * - mode: Current operational mode
 * - parserState: State when in parser/compiler mode
 * - simulatorState: State when in simulator mode
 * - alphabet: Global symbol table
 * 
 * Invariants:
 * - Active state matches current mode
 * - States are well-formed
 * - Alphabet is consistent with active state
 */
SystemMode ::= PARSING | COMPILING | SIMULATING | IDLE

schema SystemState
  mode: SystemMode
  parserState: ParserState option
  simulatorState: SimulatorState option
  alphabet: Alphabet
where
  -- Parser state exists when in parser/compiler mode
  mode âˆˆ {PARSING, COMPILING} â‡” parserState â‰  none
  
  -- Simulator state exists when in simulator mode
  mode = SIMULATING â‡” simulatorState â‰  none
  
  -- Alphabet is populated when in use
  mode â‰  IDLE â‡’ 
    #alphabet.objects > 0 âˆ¨
    #alphabet.labels > 0 âˆ¨
    #alphabet.features > 0
end

/* ============================================================================
 * SECTION 4: STATE INVARIANTS
 * ============================================================================ */

/*
 * WellFormedParserState: Parser state consistency
 * 
 * Defines global invariants that must hold throughout parsing.
 */
schema WellFormedParserState
  ParserState
where
  -- If structure is defined, it must be in memory
  hasStructure = TRUE â‡’ 
    âˆƒ node: Node â€¢ 
      node.type = MEMBRANE_STRUCTURE âˆ§
      descendant(root, node)
  
  -- All referenced modules exist
  âˆ€ node: Node â€¢ 
    node.type = CALL â‡’ 
      âˆƒ name: String â€¢ 
        name âˆˆ dom modules âˆ§
        moduleMatches(node, modules(name))
  
  -- Pattern usage is consistent
  âˆ€ patternName: dom patterns â€¢ 
    patternName âˆˆ dom models â‡’ 
      patternUsedInModel(patternName, models(patternName))
end

-- Helper predicates
descendant: Node Ã— Node â†’ ð”¹
moduleMatches: Node Ã— Node â†’ ð”¹
patternUsedInModel: String Ã— Semantics â†’ ð”¹

/*
 * WellFormedSimulatorState: Simulator state consistency
 * 
 * Defines global invariants that must hold throughout simulation.
 */
schema WellFormedSimulatorState
  SimulatorState
where
  -- Configuration membranes form a tree
  âˆ€ i: dom configuration.membranes â€¢ 
    configuration.membranes(i).parent â‰  -2 â‡’ 
      noMembraneLoops(configuration, i)
  
  -- All rules in ruleSets come from the P-system
  âˆ€ label: dom ruleSets.rules â€¢ 
    âˆ€ charge: dom ruleSets.rules(label) â€¢ 
      âˆ€ rule: ran ruleSets.rules(label)(charge) â€¢ 
        rule âˆˆ file.psystem.rules
  
  -- Selected rules are applicable
  âˆ€ sr: selectedRules â€¢ 
    let m = configuration.membranes(sr.membraneId) in
    let rules = ruleSets.rules(m.label)(m.charge.charge) in
    sr.ruleIndex âˆˆ dom rules âˆ§
    canApply(m, rules(sr.ruleIndex), sr.applications, configuration)
end

-- Helper predicates
noMembraneLoops: Configuration Ã— â„• â†’ ð”¹
canApply: CMembrane Ã— Rule Ã— â„• Ã— Configuration â†’ ð”¹

âˆ€ config: Configuration, idx: â„• â€¢
  noMembraneLoops(config, idx) â‡” 
    let visited: â„™ â„• = {idx} in
    âˆ€ parent: â„• â€¢ 
      isAncestor(config, parent, idx) â‡’ parent âˆ‰ visited

isAncestor: Configuration Ã— â„• Ã— â„• â†’ ð”¹

âˆ€ config: Configuration, ancestor, descendant: â„• â€¢
  isAncestor(config, ancestor, descendant) â‡” 
    let m = config.membranes(descendant) in
    m.parent = ancestor âˆ¨
    (m.parent â‰  -1 âˆ§ isAncestor(config, ancestor, m.parent))

/* ============================================================================
 * SECTION 5: STATE TRANSITIONS (PREVIEW)
 * ============================================================================ */

/*
 * StateTransition: Abstract state change
 * 
 * Represents a transition from one system state to another.
 * Specific operations will refine this schema.
 */
schema StateTransition
  Î”SystemState
  -- Additional components will be added in operations.zpp
where
  -- Time never goes backward in simulator
  mode = SIMULATING âˆ§ mode' = SIMULATING â‡’ 
    let ss = the simulatorState in
    let ss' = the simulatorState' in
    ss'.configuration.time â‰¥ ss.configuration.time
  
  -- Alphabet only grows
  alphabet.objects âŠ† alphabet'.objects âˆ§
  alphabet.labels âŠ† alphabet'.labels âˆ§
  alphabet.features âŠ† alphabet'.features
end

/* ============================================================================
 * SECTION 6: QUERY OPERATIONS (READ-ONLY)
 * ============================================================================ */

/*
 * GetConfiguration: Read current configuration
 * 
 * Returns the current P-system configuration when in simulator mode.
 */
schema GetConfiguration
  ÎžSystemState
  config!: Configuration
where
  mode = SIMULATING
  config! = the (simulatorState).configuration
end

/*
 * GetPsystem: Read compiled P-system
 * 
 * Returns the P-system specification when available.
 */
schema GetPsystem
  ÎžSystemState
  psystem!: Psystem
where
  mode âˆˆ {COMPILING, SIMULATING}
  
  mode = COMPILING â‡’ 
    psystem! = constructedPsystem(parserState)
  
  mode = SIMULATING â‡’ 
    psystem! = the (simulatorState).file.psystem
end

-- Helper function to extract P-system from parser state
constructedPsystem: ParserState â†’ Psystem

/*
 * GetSyntaxTree: Read parser syntax tree
 * 
 * Returns the abstract syntax tree when in parser mode.
 */
schema GetSyntaxTree
  ÎžSystemState
  tree!: Node
where
  mode âˆˆ {PARSING, COMPILING}
  tree! = the (parserState).root
end

/*
 * CheckFinished: Check if simulation is complete
 * 
 * Determines whether simulation has finished.
 */
schema CheckFinished
  ÎžSystemState
  finished!: ð”¹
where
  mode = SIMULATING
  finished! = the (simulatorState).finished
end

/* ============================================================================
 * SECTION 7: ERROR HANDLING STATE
 * ============================================================================ */

/*
 * ErrorState: System error condition
 * 
 * Represents an error state where the system cannot proceed.
 * 
 * Components:
 * - level: Severity of the error
 * - message: Error description
 * - location: Source location (if applicable)
 */
schema ErrorState
  level: ErrorLevel
  message: String
  location: Location option
where
  level âˆˆ {FATAL, ERROR}
  #message.str_ > 0
end

/*
 * SystemStateWithError: State that may have errors
 * 
 * Extends SystemState with error information.
 */
schema SystemStateWithError
  SystemState
  errors: seq ErrorState
  warnings: seq ErrorState
where
  -- Errors have appropriate level
  âˆ€ e: ran errors â€¢ e.level âˆˆ {FATAL, ERROR}
  
  -- Warnings have appropriate level
  âˆ€ w: ran warnings â€¢ w.level = WARNING
  
  -- Fatal errors prevent further processing
  (âˆƒ e: ran errors â€¢ e.level = FATAL) â‡’ mode = IDLE
end

/* ============================================================================
 * END OF SYSTEM STATE SPECIFICATION
 * ============================================================================ */
