/*
 * P-Lingua Data Model Formal Specification (Z++)
 * 
 * This specification formally defines the data structures used in P-Lingua
 * for representing membrane computing systems (P-systems).
 * 
 * The specification follows the implementation in include/serialization.hpp
 * and provides a rigorous mathematical foundation for the P-Lingua data model.
 */

/* ============================================================================
 * SECTION 1: BASIC TYPE DEFINITIONS
 * ============================================================================ */

/*
 * ValueType: Enumeration of supported primitive types
 * 
 * P-Lingua supports various primitive types for values stored in features,
 * global variables, and computational expressions.
 */
ValueType ::= CHAR | UCHAR | SHORT | USHORT | INT | UINT | LONG | DOUBLE | STRING

/*
 * Value: Generic value container
 * 
 * A Value represents a typed piece of data that can be one of several
 * primitive types. This is used throughout P-Lingua for feature values,
 * global variables, and expression results.
 * 
 * Invariants:
 * - The value's type determines which field of the union is valid
 * - String values must be properly null-terminated
 */
schema Value
  type_: ValueType
  charValue: â„¤       -- For CHAR type (-128..127)
  ucharValue: â„•      -- For UCHAR type (0..255)
  shortValue: â„¤      -- For SHORT type
  ushortValue: â„•     -- For USHORT type
  intValue: â„¤        -- For INT type
  uintValue: â„•       -- For UINT type
  longValue: â„¤       -- For LONG type
  doubleValue: â„     -- For DOUBLE type
  stringValue: seq â„¤ -- For STRING type (null-terminated)
where
  -- Type-specific constraints
  type_ = CHAR â‡’ charValue âˆˆ -128..127
  type_ = UCHAR â‡’ ucharValue âˆˆ 0..255
  type_ = STRING â‡’ #stringValue > 0 âˆ§ stringValue(#stringValue) = 0
end

/*
 * Multiplicity: Object count in multisets
 * 
 * Represents the number of occurrences of an object in a multiset.
 * Must be non-negative.
 */
schema Multiplicity
  multiplicity: â„•
where
  multiplicity â‰¥ 0
end

/*
 * String: Base class for typed strings
 * 
 * A string is a sequence of characters used for identifiers.
 * Different subclasses provide semantic typing for different uses.
 */
schema String
  str_: seq â„¤
where
  #str_ > 0  -- Non-empty
end

/*
 * ObjectString: String representing an object identifier
 * 
 * Objects are the atomic entities that populate multisets.
 * Examples: "a", "b{1}", "protein_X"
 */
schema ObjectString
  String
where
  -- Inherits all constraints from String
end

/*
 * LabelString: String representing a membrane label component
 * 
 * Labels identify membrane types and can be hierarchical.
 * Examples: "skin", "nucleus", "1"
 */
schema LabelString
  String
where
  -- Inherits all constraints from String
end

/*
 * FeatureString: String representing a feature name
 * 
 * Features are key-value pairs attached to rules and systems.
 * Examples: "priority", "probability", "pattern"
 */
schema FeatureString
  String
where
  -- Inherits all constraints from String
end

/* ============================================================================
 * SECTION 2: COMPOSITE DATA STRUCTURES
 * ============================================================================ */

/*
 * Label: Hierarchical membrane identifier
 * 
 * A label is a sequence of label strings that uniquely identify a membrane
 * type within a P-system. Labels can be compared and used to index membranes.
 * 
 * Examples: ["1"], ["skin", "2"], ["nucleus", "inner", "1"]
 */
schema Label
  components: seq LabelString
where
  #components > 0  -- At least one component
end

/*
 * Multiset: Collection of objects with multiplicities
 * 
 * A multiset maps object identifiers to their multiplicities.
 * This is the fundamental data structure for representing the contents
 * of membranes and the left/right-hand sides of rules.
 * 
 * Invariants:
 * - All multiplicities are positive (objects with zero multiplicity are removed)
 * - Objects are unique (no duplicate keys)
 */
schema Multiset
  objects: ObjectString â‡¸ Multiplicity
where
  âˆ€ obj: dom objects â€¢ objects(obj).multiplicity > 0
end

/*
 * Features: Named properties with values
 * 
 * Features provide extensibility by allowing arbitrary key-value pairs
 * to be attached to rules, systems, and other entities.
 * 
 * Common features:
 * - priority: â„¤ (rule execution priority)
 * - probability: â„ (stochastic rule probability)
 * - pattern: STRING (semantic pattern name)
 */
schema Features
  attributes: FeatureString â‡¸ Value
where
  -- All features must have valid values
  âˆ€ key: dom attributes â€¢ 
    attributes(key).type_ âˆˆ ValueType
end

/* ============================================================================
 * SECTION 3: MEMBRANE STRUCTURES
 * ============================================================================ */

/*
 * Charge: Electrical state of a membrane
 * 
 * Membranes can have negative (-1), neutral (0), or positive (+1) charge.
 * Charge affects rule applicability and membrane behavior.
 */
Charge ::= NEGATIVE | NEUTRAL | POSITIVE

schema ChargeValue
  charge: â„¤
where
  charge âˆˆ {-1, 0, 1}
end

/*
 * LeafMembrane: Base membrane structure
 * 
 * The minimal membrane contains a charge and a label.
 * This serves as the base for more complex membrane types.
 */
schema LeafMembrane
  charge: ChargeValue
  label: Label
where
  -- No additional constraints beyond field types
end

/*
 * Membrane: Hierarchical membrane structure
 * 
 * A membrane can contain other membranes, forming a tree structure.
 * This represents the static structure defined in P-Lingua source code.
 * 
 * Invariants:
 * - No cycles in the membrane hierarchy
 * - Each child membrane has a unique label within its parent
 */
schema Membrane
  LeafMembrane
  children: seq Membrane
where
  -- Unique labels among children
  âˆ€ i, j: dom children â€¢ i â‰  j â‡’ children(i).label â‰  children(j).label
end

/*
 * IMembrane: Inner membrane (with multiset)
 * 
 * An inner membrane extends a leaf membrane with a multiset of objects.
 * This is used in rules to specify the contents of nested membranes.
 */
schema IMembrane
  LeafMembrane
  multiset: Multiset
where
  -- Multiset must be well-formed
  âˆ€ obj: dom multiset.objects â€¢ 
    multiset.objects(obj).multiplicity > 0
end

/*
 * OMembrane: Outer membrane (for rules)
 * 
 * An outer membrane is used in rules to represent a membrane with its
 * contents and potentially inner membranes. It combines IMembrane with
 * a sequence of inner membranes.
 * 
 * Invariants:
 * - Inner membranes have unique labels
 * - All inner membranes are well-formed
 */
schema OMembrane
  IMembrane
  innerMembranes: seq IMembrane
where
  -- Unique labels among inner membranes
  âˆ€ i, j: dom innerMembranes â€¢ 
    i â‰  j â‡’ innerMembranes(i).label â‰  innerMembranes(j).label
end

/* ============================================================================
 * SECTION 4: EVOLUTION RULES
 * ============================================================================ */

/*
 * ArrowType: Type of rule arrow
 * 
 * Different arrow types indicate different rule semantics:
 * - FORWARD (-->): Standard evolution rule
 * - BIDIRECTIONAL (<-->): Communication rule between membranes
 */
ArrowType ::= FORWARD | BIDIRECTIONAL

/*
 * HR: Hand Rule (base for LHR and RHR)
 * 
 * Both left-hand and right-hand sides of rules contain a multiset
 * of objects that exist outside the specified membrane.
 */
schema HR
  multiset: Multiset
where
  -- Multiset is well-formed
end

/*
 * LHR: Left-Hand Rule
 * 
 * The left-hand side specifies:
 * - Objects in the parent region (multiset)
 * - A membrane with its contents and inner membranes
 * 
 * The LHR defines the pattern that must be matched for the rule to apply.
 * 
 * Invariants:
 * - The membrane structure must be well-formed
 * - All multisets must contain only objects with positive multiplicities
 */
schema LHR
  HR
  membrane: OMembrane
where
  -- Membrane is well-formed
  âˆ€ obj: dom membrane.multiset.objects â€¢ 
    membrane.multiset.objects(obj).multiplicity > 0
end

/*
 * RHR: Right-Hand Rule
 * 
 * The right-hand side specifies:
 * - Objects in the parent region (multiset)
 * - A sequence of membranes produced by the rule
 * 
 * The RHR defines what is produced when the rule is applied.
 * 
 * Special cases:
 * - Empty sequence: membrane dissolution
 * - Multiple membranes: membrane division
 * - Single membrane: standard evolution
 * 
 * Invariants:
 * - All produced membranes are well-formed
 * - Produced membranes have compatible labels with the LHR
 */
schema RHR
  HR
  producedMembranes: seq OMembrane
where
  -- All produced membranes are well-formed
  âˆ€ i: dom producedMembranes â€¢ 
    âˆ€ obj: dom producedMembranes(i).multiset.objects â€¢ 
      producedMembranes(i).multiset.objects(obj).multiplicity > 0
end

/*
 * Rule: Complete evolution rule
 * 
 * A rule specifies how membranes and objects evolve in a P-system.
 * 
 * Components:
 * - lhr: The pattern to match (what is consumed)
 * - arrow: The type of evolution
 * - rhr: What is produced
 * - features: Additional properties (priority, probability, pattern, etc.)
 * 
 * Invariants:
 * - The rule must be type-consistent
 * - Features must be compatible with the rule type
 * - Division rules must have rhr.producedMembranes.size > 1
 * - Dissolution rules must have rhr.producedMembranes.size = 0
 */
schema Rule
  lhr: LHR
  arrow: ArrowType
  rhr: RHR
  features: Features
where
  -- Type consistency
  arrow = BIDIRECTIONAL â‡’ 
    lhr.multiset.objects = âˆ… âˆ§ 
    rhr.multiset.objects = âˆ… âˆ§
    #rhr.producedMembranes = 1
  
  -- Feature constraints
  "priority" âˆˆ dom features.attributes â‡’ 
    features.attributes("priority").type_ = INT âˆ¨
    features.attributes("priority").type_ = LONG
  
  "probability" âˆˆ dom features.attributes â‡’ 
    features.attributes("probability").type_ = DOUBLE âˆ§
    features.attributes("probability").doubleValue âˆˆ 0.0..1.0
  
  "pattern" âˆˆ dom features.attributes â‡’ 
    features.attributes("pattern").type_ = STRING
end

/* ============================================================================
 * SECTION 5: SEMANTICS AND PATTERNS
 * ============================================================================ */

/*
 * Semantics: Rule application constraints
 * 
 * Semantics define how rules can be applied in a P-system.
 * This can include constraints on the number of applications,
 * which patterns are allowed, and hierarchical composition.
 * 
 * Components:
 * - value: Maximum number of applications (or âˆž)
 * - inf: Whether unlimited applications are allowed
 * - patterns: Set of pattern names this semantics node allows
 * - children: Hierarchical semantic composition
 * 
 * Invariants:
 * - If inf is true, value is ignored
 * - Patterns must be disjoint across siblings
 */
schema Semantics
  value: â„•
  inf: ð”¹
  patterns: â„™ String
  children: seq Semantics
where
  -- If infinite, value is irrelevant
  inf = TRUE â‡’ value = 0
  
  -- Disjoint patterns across siblings
  âˆ€ i, j: dom children â€¢ i â‰  j â‡’ 
    children(i).patterns âˆ© children(j).patterns = âˆ…
end

/* ============================================================================
 * SECTION 6: P-SYSTEM DEFINITION
 * ============================================================================ */

/*
 * Psystem: Complete P-system specification
 * 
 * A P-system consists of:
 * - model: Name of the membrane computing model
 * - structure: Initial membrane hierarchy
 * - multisets: Initial contents for each membrane label
 * - rules: Set of evolution rules
 * - semantics: Constraints on rule application
 * - features: Global system properties
 * 
 * Invariants:
 * - All rules are well-formed
 * - All rules reference labels that exist in the structure
 * - All multisets reference labels that exist in the structure
 * - Semantics patterns match rule patterns
 */
schema Psystem
  model: String
  structure: Membrane
  multisets: Label â‡¸ Multiset
  rules: â„™ Rule
  semantics: Semantics
  features: Features
where
  -- All multisets correspond to existing labels
  âˆ€ label: dom multisets â€¢ 
    existsInStructure(structure, label)
  
  -- All rules reference existing labels
  âˆ€ rule: rules â€¢ 
    existsInStructure(structure, rule.lhr.membrane.label)
  
  -- Pattern consistency
  âˆ€ rule: rules â€¢ 
    "pattern" âˆˆ dom rule.features.attributes â‡’ 
      existsInSemantics(semantics, 
        rule.features.attributes("pattern").stringValue)
end

/* Helper functions (axiomatic definitions) */

-- Check if a label exists somewhere in the membrane structure
existsInStructure: Membrane Ã— Label â†’ ð”¹

âˆ€ m: Membrane, l: Label â€¢
  existsInStructure(m, l) â‡” 
    m.label = l âˆ¨ 
    (âˆƒ child: ran m.children â€¢ existsInStructure(child, l))

-- Check if a pattern exists in the semantics tree
existsInSemantics: Semantics Ã— seq â„¤ â†’ ð”¹

âˆ€ s: Semantics, pattern: seq â„¤ â€¢
  existsInSemantics(s, pattern) â‡” 
    (âˆƒ p: s.patterns â€¢ p.str_ = pattern) âˆ¨
    (âˆƒ child: ran s.children â€¢ existsInSemantics(child, pattern))

/* ============================================================================
 * SECTION 7: RUNTIME CONFIGURATION
 * ============================================================================ */

/*
 * CMembrane: Configuration membrane (runtime state)
 * 
 * During simulation, membranes are represented as CMembrane instances
 * which include runtime information:
 * - parent: Index of parent membrane (-1 for root)
 * - children: Indices of child membranes
 * - priorityLevel: Current priority level for rule application
 * - semantics: Current semantic constraints
 * 
 * Invariants:
 * - Parent-child relationships are consistent
 * - No cycles in the membrane tree
 * - Priority level is valid
 */
schema CMembrane
  IMembrane
  parent: â„¤
  children: seq â„¤
  priorityLevel: â„¤
  semantics: Semantics
where
  -- Valid parent index
  parent â‰¥ -1
  
  -- Valid child indices
  âˆ€ child: ran children â€¢ child â‰¥ 0
  
  -- No self-reference
  parent â‰  -1 â‡’ (âˆ€ child: ran children â€¢ child â‰  parent)
end

/*
 * Configuration: P-system runtime state
 * 
 * A configuration represents the complete state of a P-system at a
 * specific point in time during simulation.
 * 
 * Components:
 * - time: Current simulation time step
 * - environment: Objects in the environment (outside all membranes)
 * - membranes: All membranes in the system
 * 
 * Invariants:
 * - Exactly one root membrane (parent = -1)
 * - Parent-child relationships form a tree
 * - All child indices are valid
 * - No membrane cycles
 */
schema Configuration
  time: â„•
  environment: Multiset
  membranes: seq CMembrane
where
  -- Exactly one root
  #{ i: dom membranes | membranes(i).parent = -1 } = 1
  
  -- Valid parent-child relationships
  âˆ€ i: dom membranes â€¢ 
    membranes(i).parent â‰  -1 â‡’ 
      membranes(i).parent âˆˆ dom membranes âˆ§
      i âˆˆ ran membranes(membranes(i).parent).children
  
  -- Valid child indices
  âˆ€ i: dom membranes â€¢ 
    âˆ€ child: ran membranes(i).children â€¢ 
      child âˆˆ dom membranes âˆ§
      membranes(child).parent = i
  
  -- No cycles (enforced by tree structure)
  -- This is implicitly guaranteed by the parent pointer forming a tree
end

/*
 * File: Serializable P-system
 * 
 * A File represents a complete P-system that can be serialized to/from
 * various formats (JSON, XML, Binary).
 * 
 * Components:
 * - header: File format identifier
 * - version: P-Lingua version
 * - psystem: The actual P-system specification
 */
schema File
  header: String
  version: String
  psystem: Psystem
where
  header.str_ = "P-Lingua output file"
  #version.str_ > 0
end

/* ============================================================================
 * SECTION 8: ALPHABET AND IDENTIFIERS
 * ============================================================================ */

/*
 * UId: Unique identifier
 * 
 * During serialization, strings are replaced with unique integer IDs
 * for efficiency. A UId represents a compressed identifier.
 * 
 * Components:
 * - id: The unique integer identifier
 * - max: The maximum ID value in the alphabet
 * 
 * Invariants:
 * - ID is within valid range
 */
schema UId
  id: â„•
  max: â„•
where
  id â‰¤ max
end

/*
 * Alphabet: Global symbol table
 * 
 * The Alphabet maintains mappings between strings and unique IDs
 * for objects, labels, features, and general strings.
 * 
 * Invariants:
 * - All mappings are bijective
 * - IDs are contiguous (0..size-1)
 * - Maximum multiplicity tracks the largest object count
 */
schema Alphabet
  objects: String â¤– UId
  labels: String â¤– UId
  features: String â¤– UId
  strings: String â¤– UId
  maxMultiplicity: â„•
where
  -- Bijective mappings
  objects âˆˆ String â¤– UId
  labels âˆˆ String â¤– UId
  features âˆˆ String â¤– UId
  strings âˆˆ String â¤– UId
  
  -- Contiguous IDs
  âˆ€ category: {objects, labels, features, strings} â€¢
    let size = #category in
    (âˆ€ s: dom category â€¢ category(s).id < size) âˆ§
    (âˆ€ i: 0..(size-1) â€¢ âˆƒ s: dom category â€¢ category(s).id = i)
  
  -- Max multiplicity is reasonable
  maxMultiplicity > 0
end

/* ============================================================================
 * END OF DATA MODEL SPECIFICATION
 * ============================================================================ */
