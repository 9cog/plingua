/*
 * 3-SAT Problem Solver
 * 
 * Solves the Boolean satisfiability problem in 3-CNF form.
 * Given a formula with variables and 3-literal clauses, find a
 * satisfying assignment.
 * 
 * Concept: Generate all 2^n assignments, check each against clauses
 * Difficulty: Expert
 * 
 * Copyright (C) 2024 Research Group On Natural Computing
 */

@model<membrane_division>
@include "../membrane_division_model.pli"

def threeSAT(numVars, numClauses)
{
    @mu = [[]'2]'1;
    
    // Start with variable 0
    @ms(2) = var{0}, step{0};
    
    // Example 3-SAT formula:
    // (x0 ∨ ¬x1 ∨ x2) ∧ (¬x0 ∨ x1 ∨ ¬x2) ∧ (x0 ∨ x1 ∨ x2)
    // Represented as: clause{id, lit1, lit2, lit3}
    // Positive literal: variable number, Negative: -(var+1)
    @ms(2) += clause{0,0,-2,2},    // x0 ∨ ¬x1 ∨ x2
              clause{1,-1,1,-3},    // ¬x0 ∨ x1 ∨ ¬x2
              clause{2,0,1,2};      // x0 ∨ x1 ∨ x2
    
    // For each variable: create true/false branches
    [var{i}, step{s}]'2 --> 
        [var{i}, assign{i,1}, var{i+1}, step{s}]'2   // Assign true
        [var{i}, assign{i,0}, var{i+1}, step{s}]'2   // Assign false
        : 0 <= i < numVars;
    
    // Evaluate clauses: check if at least one literal is true
    [clause{id,l1,l2,l3}, assign{v1,val1}, assign{v2,val2}, assign{v3,val3}]'2 -->
        [satisfied{id}]'2
        : (l1 >= 0 && v1 == l1 && val1 == 1) ||
          (l1 < 0 && v1 == -(l1+1) && val1 == 0) ||
          (l2 >= 0 && v2 == l2 && val2 == 1) ||
          (l2 < 0 && v2 == -(l2+1) && val2 == 0) ||
          (l3 >= 0 && v3 == l3 && val3 == 1) ||
          (l3 < 0 && v3 == -(l3+1) && val3 == 0);
    
    // Check if all clauses satisfied
    [var{numVars}, satisfied{i}]'2 --> [solution]'2
        : 0 <= i < numClauses;
}

def main()
{
    // Solve 3-SAT with 3 variables and 3 clauses
    call threeSAT(3, 3);
}
