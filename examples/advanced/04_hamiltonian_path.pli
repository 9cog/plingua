/*
 * Hamiltonian Path Problem
 * 
 * Finds a path in a graph that visits each vertex exactly once.
 * This is an NP-complete problem.
 * 
 * Concept: Path exploration using non-deterministic choice
 * Difficulty: Advanced
 * 
 * Copyright (C) 2024 Research Group On Natural Computing
 */

@model<membrane_division>
@include "../membrane_division_model.pli"

def hamiltonianPath(n)
{
    @mu = [[]'2]'1;
    
    // Start from vertex 0
    @ms(2) = current{0}, visited{0}, step{0};
    
    // Define graph edges as edge{from,to}
    @ms(2) += edge{0,1}, edge{0,2},
              edge{1,2}, edge{1,3},
              edge{2,3}, edge{2,4},
              edge{3,4};
    
    // Non-deterministically choose next vertex
    [current{v}, edge{v,u}, visited{mask}, step{s}]'2 -->
        [current{u}, edge{v,u}, visited{mask|(1<<u)}, step{s+1}]'2
        [current{v}, edge{v,u}, visited{mask}, step{s}]'2
        : 0 <= v < n, 0 <= u < n, (mask & (1<<u)) == 0;
    
    // Solution found when all vertices visited
    [step{s}, visited{mask}]'2 --> [hamiltonian_path]'2
        : s == n-1, mask == (1<<n)-1;
    
    // Invalid paths are discarded
    [step{s}, visited{mask}]'2 --> [no_path]'2
        : s < n-1;
}

def main()
{
    // Find Hamiltonian path in 5-vertex graph
    call hamiltonianPath(5);
}
