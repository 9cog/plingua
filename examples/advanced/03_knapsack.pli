/*
 * 0/1 Knapsack Problem
 * 
 * Given items with weights and values, and a knapsack capacity,
 * find the maximum value subset that fits in the knapsack.
 * 
 * Concept: Dynamic programming or brute-force with division
 * Difficulty: Advanced
 * 
 * Copyright (C) 2024 Research Group On Natural Computing
 */

@model<membrane_division>
@include "../membrane_division_model.pli"

def knapsack(n, capacity)
{
    @mu = [[]'2]'1;
    
    // Initialize knapsack with capacity and items
    @ms(2) = weight{0}, value{0}, item{0}, cap{capacity};
    
    // Items: (weight, value) pairs
    @ms(2) += obj{0,2,3},   // Item 0: weight=2, value=3
              obj{1,3,4},   // Item 1: weight=3, value=4
              obj{2,4,5},   // Item 2: weight=4, value=5
              obj{3,5,8};   // Item 3: weight=5, value=8
    
    // For each item: decide to include or exclude
    [item{i}, obj{i,w,v}, weight{tw}, value{tv}, cap{c}]'2 -->
        // Include if fits
        [item{i+1}, obj{i,w,v}, weight{tw+w}, value{tv+v}, cap{c}]'2
        // Exclude
        [item{i+1}, obj{i,w,v}, weight{tw}, value{tv}, cap{c}]'2
        : 0 <= i < n, tw+w <= c;
    
    // Can only exclude if including would exceed capacity
    [item{i}, obj{i,w,v}, weight{tw}, value{tv}, cap{c}]'2 -->
        [item{i+1}, obj{i,w,v}, weight{tw}, value{tv}, cap{c}]'2
        : 0 <= i < n, tw+w > c;
    
    // Mark solutions with final value
    [item{n}, value{v}]'2 --> [solution{v}]'2;
}

def main()
{
    // Solve knapsack with capacity 7
    call knapsack(4, 7);
    // Optimal: items 0,1,3 -> weight=2+3=5, value=3+4=8=15
}
